{
  "hash": "7561a30f72a0bdb9b68972603d89e15f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Supply Chain Data Analytics\nsubtitle: Analyzing and Forcasting Supermarket Sales\nauthors:\n  - name: Stan Brouwer\n    orchid: 0009-0006-3447-0096\n    affiliation: Vrije Universiteit\n    corresponding: true\n  - name: Liz Chan\n    affiliation: Master TSCM\n  - name: Maaike Lamberst\n    affiliation: Supply Chain Data analysis\n  - name: Niek Schroor\n    affiliation: Group 10\n\ndate: last-modified\nbibliography: references.bib\ncitation:\n  container-title: Earth and Space Science\nnumber-sections: true\n---\n\n\n\n\n\n<h2>Introduction</h2>\n\nWe analyze, forecast and interpret the [Superstore sales](https://public.tableau.com/app/sample-data/sample_-_superstore.xls) provided by [Tableau](https://public.tableau.com/app/learn/sample-data) using different statistical and machine learning methods.\n\nWe describe our work in the PDF version. However, we would like to recommend reading our quarto manuscript *here* as it contains the **relevant** R code in the Article Notebook.\n\n## Data Pre-processing\n\nThe superstore data set we selected is of high quality. Thus we do the required data pre-processing, but included the hypothetical steps we would take were our data of lower quality to communicate our understanding of the data pre-processing process.\n\nWe took the following pre-processing steps:\n\n\n\n\n\n::: {.cell .hidden}\n\n```{.r .cell-code .hidden}\n# Clear workspace\nrm(list = ls())\n# Function to load (and install if necessary) dependencies\ninstall_and_load <- function(packages) {\n  install.packages(setdiff(packages, rownames(installed.packages())), dependencies = TRUE)\n  invisible(lapply(packages, require, character.only = TRUE))\n}\ninstall_and_load(c(\"tidyverse\", \"readxl\", \"ggplot2\", \"lubridate\", \"stats\", \"Amelia\",\"forecast\", \"tseries\", \"plotly\", \"stringr\", \"knitr\"))\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nLoading required package: tidyverse\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n-- Attaching core tidyverse packages ------------------------ tidyverse 2.0.0 --\nv dplyr     1.1.4     v readr     2.1.5\nv forcats   1.0.0     v stringr   1.5.1\nv ggplot2   3.5.1     v tibble    3.2.1\nv lubridate 1.9.3     v tidyr     1.3.1\nv purrr     1.0.2     \n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\ni Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\nLoading required package: readxl\n\nLoading required package: Amelia\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'Amelia' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nLoading required package: Rcpp\n## \n## Amelia II: Multiple Imputation\n## (Version 1.8.3, built: 2024-11-07)\n## Copyright (C) 2005-2024 James Honaker, Gary King and Matthew Blackwell\n## Refer to http://gking.harvard.edu/amelia/ for more information\n## \nLoading required package: forecast\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'forecast' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nRegistered S3 method overwritten by 'quantmod':\n  method            from\n  as.zoo.data.frame zoo \nLoading required package: tseries\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'tseries' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nLoading required package: plotly\n\nAttaching package: 'plotly'\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\nThe following object is masked from 'package:stats':\n\n    filter\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\nLoading required package: knitr\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'knitr' was built under R version 4.3.3\n```\n\n\n:::\n:::\n\n\n\n\n\n-   Improved column names by removing whitespaces\n-   Removed the <code>Row_ID</code> column as it can be inferred by it's index\n-   Removed all columns with a single unique value, as storing these would be [redundant](https://few.vu.nl/~molenaar/courses/StatR/chapters/B-06-raw_data.html)\n-   Ensured machine-readable date formats in yyyy-mm-dd as these usually differ per locale.\n-   Ensured proper decimal separators\n-   Calculated the number of missing values (both NA and empty string \"\") per column.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Load the data\nsuppressWarnings({data <- read_excel(\"data/sample_-_superstore.xls\")}) # The Postal code column is stored as 'text' but coerced to numeric, causing warnings which we suppress\n\n# Improve column names\ncolnames(data) <- str_replace_all(colnames(data), \" \", \"_\")\ncolnames(data) <- str_replace_all(colnames(data), \"-\", \"_\")\n\n# Remove the 'Row_ID' column as it can be inferred by it's index\ndata <- subset(data, select = -`Row_ID`)\n\n# Remove all columns that have only one unique value, as storing these would be redundant\ndata <- data[, sapply(data, function(col) length(unique(col)) > 1)]\n\n# Ensure a machine-readable date format as these are usually horrible in excel files\ndata$Order_Date <- as.Date(data$Order_Date, format = \"%Y-%m-%d\")\ndata$Ship_Date <- as.Date(data$Ship_Date, format = \"%Y-%m-%d\")\n\n# The readxl package by default uses the correct decimal separator (as opposed to base R)\n\n# Calculate the number of missing values per column.\n# Origional dates and R date objects are in unix time, which return NA when compared to text (empty string). These dates are stored as 'double' datatype, Thus we check character columns for empty strings, and all columns for NA values. \nmissing_values <- sapply(data, function(col) {\n  if (inherits(col, \"Date\")) {\n    sum(is.na(col))\n  } else if (is.character(col)) {\n    sum(is.na(col) | col == \"\")\n  } else {\n    sum(is.na(col))\n  }\n})\n\n\nif (sum(missing_values) == 0) {\n  print(\"None of the columns contains missing values\") # We print to enforce the \"Source: Article notebook\n  } else {\n  print(\"Some columns contain missing values\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"None of the columns contains missing values\"\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\n# Optionally, print the missing values as a nice table\nmissing_values_table <- data.frame(\n  Column = names(missing_values),\n  Missing_or_Empty = missing_values\n)\n# Note that there are no missing values, thus we do not print them\n# kable(missing_values_table, caption = \"Missing or Empty Values in Columns\", format = \"pipe\")\n\n\nrm(missing_value, missing_values_table)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning in rm(missing_value, missing_values_table): object 'missing_value' not\nfound\n```\n\n\n:::\n:::\n\n\n\n\n\nAfter these steps (and transposing the table for better document formatting), the data looks as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nkable(t(head(data, 3)), caption = \"First 5 Rows of the Data (Transposed)\", format = \"markdown\")\n```\n\n::: {.cell-output-display}\n\n\nTable: First 5 Rows of the Data (Transposed)\n\n|              |                                  |                                                            |                                                          |\n|:-------------|:---------------------------------|:-----------------------------------------------------------|:---------------------------------------------------------|\n|Order_ID      |CA-2016-152156                    |CA-2016-152156                                              |CA-2016-138688                                            |\n|Order_Date    |2016-11-08                        |2016-11-08                                                  |2016-06-12                                                |\n|Ship_Date     |2016-11-11                        |2016-11-11                                                  |2016-06-16                                                |\n|Ship_Mode     |Second Class                      |Second Class                                                |Second Class                                              |\n|Customer_ID   |CG-12520                          |CG-12520                                                    |DV-13045                                                  |\n|Customer_Name |Claire Gute                       |Claire Gute                                                 |Darrin Van Huff                                           |\n|Segment       |Consumer                          |Consumer                                                    |Corporate                                                 |\n|City          |Henderson                         |Henderson                                                   |Los Angeles                                               |\n|State         |Kentucky                          |Kentucky                                                    |California                                                |\n|Postal_Code   |42420                             |42420                                                       |90036                                                     |\n|Region        |South                             |South                                                       |West                                                      |\n|Product_ID    |FUR-BO-10001798                   |FUR-CH-10000454                                             |OFF-LA-10000240                                           |\n|Category      |Furniture                         |Furniture                                                   |Office Supplies                                           |\n|Sub_Category  |Bookcases                         |Chairs                                                      |Labels                                                    |\n|Product_Name  |Bush Somerset Collection Bookcase |Hon Deluxe Fabric Upholstered Stacking Chairs, Rounded Back |Self-Adhesive Address Labels for Typewriters by Universal |\n|Sales         |261.96                            |731.94                                                      |14.62                                                     |\n|Quantity      |2                                 |3                                                           |2                                                         |\n|Discount      |0                                 |0                                                           |0                                                         |\n|Profit        |41.9136                           |219.5820                                                    |6.8714                                                    |\n\n\n:::\n:::\n\n\n\n\n\nThere is some more processing to do, for instance the removal of outliers. However, by doing so we impose our own assumptions on the data. Let's start by evaluating the descriptive statistics of our data and check if further processing is required. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ndescriptive_statistics <- function(column) {\n  if (is.numeric(column)) {\n    stats <- list(\n      Min = min(column, na.rm = TRUE), # Note that handling NA values increases robustness (and I copied the funciton from some of my earlier work)\n      Max = max(column, na.rm = TRUE),\n      Mean = mean(column, na.rm = TRUE),\n      Median = median(column, na.rm = TRUE),\n      StdDev = sd(column, na.rm = TRUE)\n    )\n  } else if (inherits(column, \"Date\")) {\n    stats <- list(\n      Earliest = format(min(column, na.rm = TRUE), \"%Y-%m-%d\"),\n      Latest = format(max(column, na.rm = TRUE), \"%Y-%m-%d\")\n    )\n  } else if (is.character(column)) {\n    stats <- list(\n      Unique = length(unique(column)),\n      Mode = names(sort(table(column), decreasing = TRUE)[1])\n    )\n  } else {\n    stats <- NULL\n  }\n  return(stats)\n}\n\n# Call function on dataframe\ndescriptive_stats <- lapply(data, descriptive_statistics)\n\n# Separate to tables dependent on data type\nnumeric_stats <- as.data.frame(do.call(rbind, lapply(names(data), function(col_name) {\n  if (is.numeric(data[[col_name]])) {\n    c(Column = col_name, descriptive_stats[[col_name]])\n  }\n})), stringsAsFactors = FALSE)\ndate_stats <- as.data.frame(do.call(rbind, lapply(names(data), function(col_name) {\n  if (inherits(data[[col_name]], \"Date\")) {\n    c(Column = col_name, descriptive_stats[[col_name]])\n  }\n})), stringsAsFactors = FALSE)\ncharacter_stats <- as.data.frame(do.call(rbind, lapply(names(data), function(col_name) {\n  if (is.character(data[[col_name]])) {\n    c(Column = col_name, descriptive_stats[[col_name]])\n  }\n})), stringsAsFactors = FALSE)\n\n# Output tables\nkable(\n  numeric_stats,\n  caption = \"Descriptive Statistics for Numeric Columns\",\n  format = \"pipe\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Descriptive Statistics for Numeric Columns\n\n|Column      |Min       |Max      |Mean      |Median  |StdDev   |\n|:-----------|:---------|:--------|:---------|:-------|:--------|\n|Postal_Code |1040      |99301    |55190.38  |56430.5 |32063.69 |\n|Sales       |0.444     |22638.48 |229.858   |54.49   |623.2451 |\n|Quantity    |1         |14       |3.789574  |3       |2.22511  |\n|Discount    |0         |0.8      |0.1562027 |0.2     |0.206452 |\n|Profit      |-6599.978 |8399.976 |28.6569   |8.6665  |234.2601 |\n\n\n:::\n\n```{.r .cell-code .hidden}\nkable(\n  date_stats,\n  caption = \"Descriptive Statistics for Date Columns\",\n  format = \"pipe\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Descriptive Statistics for Date Columns\n\n|Column     |Earliest   |Latest     |\n|:----------|:----------|:----------|\n|Order_Date |2014-01-03 |2017-12-30 |\n|Ship_Date  |2014-01-07 |2018-01-05 |\n\n\n:::\n\n```{.r .cell-code .hidden}\n# Let's not render the character table as it contains little relevant information\n#kable(\n#  character_stats,\n#  caption = \"Descriptive Statistics for Text Columns\",\n#  format = \"pipe\")\n```\n:::\n\n\n\n\n\nWe inspected the orders with the lowest and highers price (<code>Sales</code> in USD). The most expensive orders were professional printers, camera's and teleconferencing units with high unit prices, and these orders often were of high <code>Quantity</code>. The orders with the lowest price where often binders, had a high <code>Discount</code> rate, and often a <code>Quantity</code> of just one. \n\nWe were fascinated by the orders with a negative <code>profit</code>. These all had high <code>Discount</code> rates, and often concerned the same items, such as the <code>Cubify CubeX 3D Printer Triple Head Print</code>. The orders with a negative <code>Profit</code> where often part of a larger order (for instance <code>CA-2016-108196</code>), and placed by customers that placed multiple orders. We suspect these negative <code>Profit</code>'s to be caused by faulty items that receive discounts, general discount codes, or volume discounts. However, due to especially the high discounts on orders with negative profits, we assume these to be valid orders. This decision has also been influenced by the high quality of the data. As we found no missing values whats however, we suspect the chance of some weird but valid orders to be higher than encountering mistakes here. *[this paragraph could use some rewriting]*\n\nIn figure x we plotted the sales of the most popular products. Unfortunately, the sales of individual products were too low to determine any meaningfull trends. \n\n\n\n\n\n::: {.cell warnng='false'}\n\n```{.r .cell-code .hidden}\n# Optionally: print top 10 sale quantity barplot\n# # Sum of Quantity for top products\n# top_products <- data %>%\n#   group_by(Product_Name) %>%\n#   summarize(total_quantity = sum(Quantity, na.rm = TRUE)) %>%\n#   arrange(desc(total_quantity)) %>%\n#   slice_head(n = 10) %>% \n#   mutate(ProdName8 = substr(Product_Name, 1, 8)) # Truncate product names to the first 8 characters. Long names mess up formatting\n# \n# # Plot\n# ggplot(top_products, aes(x = reorder(ProdName8, -total_quantity), y = total_quantity)) +\n#   geom_bar(stat = \"identity\", fill = \"steelblue\") +\n#   labs(title = \"Top 20 Most Sold Products\",\n#        x = \"Product ID\",\n#        y = \"Total Quantity\") +\n#   theme_minimal() +\n#   coord_flip()\n\n# Aggregate quantity by Product Name and Order Date to create a time series\ntime_series_data <- data %>%\n  group_by(Product_Name, Order_Date) %>%\n  summarize(total_quantity = sum(Quantity, na.rm = TRUE)) %>%\n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n`summarise()` has grouped output by 'Product_Name'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\n# Filter for the top products by total quantity sold (adjust as needed)\ntop_products <- time_series_data %>%\n  group_by(Product_Name) %>%\n  summarize(total_quantity = sum(total_quantity)) %>%\n  arrange(desc(total_quantity)) %>%\n  slice_head(n = 10)  # Select top 10 products\n\n# Filter the time-series data for only these top products\nfiltered_time_series_data <- time_series_data %>%\n  filter(Product_Name %in% top_products$Product_Name) %>%\n  mutate(ProdName10 = substr(Product_Name, 1, 10)) # Product names can be quite long and mess up layouts. Lets only plot the first 10 chars.\n\n# Here we do some special plotting. We want to show the plot with only one selected line by default, but make sure that the other 9 top sold products can be selected. We first create the ggplotly object, and than modify the visibility of the traces\n\n# Creating the ggplotly object\np_ly <- ggplotly(ggplot(filtered_time_series_data, aes(x = Order_Date, y = total_quantity, color = ProdName10)) +\n  geom_line(size = 1) +\n  labs(title = \"Quantity Sold Over Time per Product\",\n       x = \"Order Date\",\n       y = \"Quantity Sold\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  scale_color_discrete(name = \"Product Name\"))\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\ni Please use `linewidth` instead.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\n# Modify the visibility of traces\nfor (i in seq_along(p_ly$x$data)) {\n  if (i == 1) {\n    p_ly$x$data[[i]]$visible <- TRUE  # Make the first trace visible\n  } else {\n    p_ly$x$data[[i]]$visible <- \"legendonly\"  # Hide the rest\n  }\n}\n\n# Plot\np_ly\n```\n\n::: {.cell-output-display}\n![Figure x Sale quantity of the most popular products](index_files/figure-pdf/Quantity_top_products-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\nOur proposed workaround is to aggregate products by their <code>Sub_Category</code>, and treating them as a single product for the rest of the assignment, which we plotted in figure X.\n\n\n\n\n\n::: {.cell fig-caption='Aggregated Sub_Category sales (toggle )'}\n\n```{.r .cell-code .hidden}\n# Bar plots\n\n# # Count frequency of top 20 products\n# top_products <- data %>%\n#   count(Product_Name, sort = TRUE) %>%\n#   top_n(20, n) %>%\n#   mutate(ProdName8 = substr(Product_Name, 1, 8))\n# \n# # Plot!\n# ggplot(top_products, aes(x = reorder(`ProdName8`, -n), y = n)) +\n#   geom_bar(stat = \"identity\", fill = \"steelblue\") +\n#   labs(title = \"Top 20 Most Sold Products\",\n#        x = \"Product Name\",\n#        y = \"Quantity sold\") +\n#   theme_minimal() +\n#   coord_flip()\n# \n# Count frequency of top 20 products\ntop_categories <- data %>%\n  count(Sub_Category, sort = TRUE)\n# \n# # Plot!\n# ggplot(top_categories, aes(x = reorder(Sub_Category, -n), y = n)) +\n#   geom_bar(stat = \"identity\", fill = \"steelblue\") +\n#   labs(title = \"Sub_Categories sorted\",\n#        x = \"Product Name\",\n#        y = \"Quantity sold\") +\n#   theme_minimal() +\n#   coord_flip()\n\n# Find top 10 most sold product names\ntop_10_categories <- top_categories$Sub_Category[0:10]\n\n# Filter the data for  top 10 products\ntop_10_data <- data %>% filter(Sub_Category %in% top_10_categories)\n\n# calculate sales per month\ntop_10_data <- top_10_data %>%\n  mutate(Month = floor_date(Order_Date, unit = \"month\"))\n\n# Aggregate data by month for each sub-category\ntop_10_data_aggregated <- top_10_data %>%\n  group_by(Month, Sub_Category) %>%\n  summarise(Sales_Count = n(), .groups = 'drop')\n\n# Some special interactive plot formatting (see previous plot)\np_ly <- ggplotly(ggplot(top_10_data_aggregated, aes(x = Month, y = Sales_Count, color = Sub_Category, group = Sub_Category)) +\n    geom_line(size = 1) +\n    geom_point(size = 2) +\n    labs(title = \"Monthly Sales for the Top 3 Most Sold Products\",\n         x = \"Month\",\n         y = \"Sales Count\",\n         color = \"Product Name\") +\n    theme_minimal())\n\n# Modify the visibility of traces\nfor (i in seq_along(p_ly$x$data)) {\n  if (i == 1) {\n    p_ly$x$data[[i]]$visible <- TRUE  # Make the first trace visible\n  } else {\n    p_ly$x$data[[i]]$visible <- \"legendonly\"  # Hide the rest\n  }\n}\n\n# Plot\np_ly\n```\n\n::: {.cell-output-display}\n![](index_files/figure-pdf/Aggregated_Sub_Category_sales-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nThese aggregated sales start to show trends and seasonality, and are much more useful to base predictions on! We will use these aggregated sub-categories for the rest of the assignment.\n\nTo properly finish our data pre-processing we ran some statistics on the aggregated sub-category sales. Table x contains soem descriptive statistics.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nlibrary(dplyr)\nlibrary(kableExtra)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n\nAttaching package: 'kableExtra'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nThe following object is masked from 'package:dplyr':\n\n    group_rows\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\n# Summarize the data\noutlier_summary <- data %>%\n  group_by(Sub_Category) %>%\n  summarize(\n    Min = round(min(Quantity), 2),\n    Mean = round(mean(Quantity), 2),\n    Max = round(max(Quantity), 2),\n    Sd = round(sd(Quantity), 2),\n    CI_lower = round(Mean - 1.96 * (Sd / sqrt(n())), 2),\n    CI_upper = round(Mean + 1.96 * (Sd / sqrt(n())), 2),\n    .groups = \"drop\"\n  )\n\n\n# Output tables\nkable(\n  outlier_summary,\n  caption = \"Statistics for Sub_Category quantity\",\n  format = \"pipe\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Statistics for Sub_Category quantity\n\n|Sub_Category | Min| Mean| Max|   Sd| CI_lower| CI_upper|\n|:------------|---:|----:|---:|----:|--------:|--------:|\n|Accessories  |   1| 3.84|  14| 2.28|     3.68|     4.00|\n|Appliances   |   1| 3.71|  14| 2.12|     3.52|     3.90|\n|Art          |   1| 3.77|  14| 2.13|     3.62|     3.92|\n|Binders      |   1| 3.92|  14| 2.29|     3.80|     4.04|\n|Bookcases    |   1| 3.81|  13| 2.28|     3.51|     4.11|\n|Chairs       |   1| 3.82|  14| 2.28|     3.64|     4.00|\n|Copiers      |   1| 3.44|   9| 1.83|     3.01|     3.87|\n|Envelopes    |   1| 3.57|   9| 2.05|     3.32|     3.82|\n|Fasteners    |   1| 4.21|  14| 2.41|     3.89|     4.53|\n|Furnishings  |   1| 3.72|  14| 2.16|     3.58|     3.86|\n|Labels       |   1| 3.85|  14| 2.35|     3.61|     4.09|\n|Machines     |   1| 3.83|  11| 2.17|     3.43|     4.23|\n|Paper        |   1| 3.78|  14| 2.23|     3.66|     3.90|\n|Phones       |   1| 3.70|  14| 2.19|     3.56|     3.84|\n|Storage      |   1| 3.73|  14| 2.19|     3.58|     3.88|\n|Supplies     |   1| 3.41|  10| 1.84|     3.15|     3.67|\n|Tables       |   1| 3.89|  13| 2.45|     3.62|     4.16|\n\n\n:::\n:::\n\n\n\n\n\nThe statistics for the sales aggregated by product category look valid. We can further inspect them by visualizing them as histogram and visually check for anomalies. Figure y contains histograms of the quantities per sub-category. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nsub_categories <- unique(data$Sub_Category)\n\np <- plot_ly()\nfor (i in seq_along(sub_categories)) {\n  sub <- sub_categories[i]\n  subset_data <- data %>% filter(Sub_Category == sub)\n  p <- add_trace(\n    p,\n    x = subset_data$Quantity,\n    type = \"histogram\",\n    name = sub,\n    visible = ifelse(i == 1, TRUE, FALSE)\n  )\n}\n\n# We add a drop down menu for Sub_Category as toggling visibility in default ggplot2 adds the histograms up. Instead we want to be able to show each histogram seperately. \ndropdown_buttons <- lapply(seq_along(sub_categories), function(i) {\n  list(\n    method = \"update\",\n    args = list(\n      list(visible = lapply(seq_along(sub_categories), function(j) j == i)),\n      list(xaxis = list(title = \"Quantity\", autorange = TRUE), \n           yaxis = list(title = \"Frequency\", autorange = TRUE))\n    ),\n    label = sub_categories[i]\n  )\n})\n\n# Style drop down layout\np <- p %>%\n  layout(\n    title = \"Distribution of Quantity Sold per Order by Sub-Category\",\n    xaxis = list(title = \"Quantity\"),\n    yaxis = list(title = \"Frequency\"),\n    showlegend = FALSE,  # Drop down instead of legend\n    updatemenus = list(\n      list(\n        type = \"dropdown\",\n        buttons = dropdown_buttons,\n        direction = \"down\",\n        x = 0.99,\n        y = 0.99,\n        showactive = TRUE,\n        xanchor = \"left\",\n        yanchor = \"top\"\n      )\n    )\n  )\np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-pdf/sub_category_histograms-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nThe histograms show that the quantities are not normally distributed, but have a right-skewed distribution. This is expected as most orders contain a small number of items, but some orders contain a large number of items. We will not remove these outliers as they are valid orders.\n\nAs the data we are going to use seems valid, we move on to exploring the trends and visualizing our data.\n\n## Data Visualization\n\n\n\n\n\nsome text for the visualization\n\n\n",
    "supporting": [
      "index_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "\\usepackage{booktabs}\n\\usepackage{longtable}\n\\usepackage{array}\n\\usepackage{multirow}\n\\usepackage{wrapfig}\n\\usepackage{float}\n\\usepackage{colortbl}\n\\usepackage{pdflscape}\n\\usepackage{tabu}\n\\usepackage{threeparttable}\n\\usepackage{threeparttablex}\n\\usepackage[normalem]{ulem}\n\\usepackage{makecell}\n\\usepackage{xcolor}\n"
      ]
    },
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}